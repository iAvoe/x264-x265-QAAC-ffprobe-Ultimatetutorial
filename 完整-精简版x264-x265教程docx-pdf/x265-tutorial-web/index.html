<!DOCTYPE html>
<html lang='zh-hans'>
	<head>
        <meta charset="UTF-8" name="viewport" content="width=device-width,initial-scale=0.8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">

        <!-- Basic Bootstrap Javascript <script src="./files/bootstrap.min.js"></script> -->
        <!-- Bootstrap CSS <link rel="stylesheet" href="./files/bootstrap.css"> -->
        <!-- Bootstrap Icons CSS (remote)
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/span/bootstrap-icons.css" crossorigin="anonymous">
        -->
        
        <!-- JavaScript Codes -->
        <script src="./files/tutorialExperimental.js" defer></script>

        <!-- Custom CSS Codes -->
        <link rel="stylesheet" href="./files/tutorialExperimental.css">

        <!--
            Example run function
            function runCommon() {
            let s1 = document.getElementById("string1").value;
            let s2 = document.getElementById("string2").value;
            document.getElementById("output").value = common(s1，s2);
        }-->
        <title>x265教程 HTML 版</title>
	</head>
	<body class="text-gray-main">
        <div class="container p-3 mt-3 rounded-9 border-main">
            <h1>x265教程<span class="text-blue-emph"> HTML 完整版</span></h1>
            <p class="text-gray-side">欢迎阅读！若有什么不会的可以加群<a href='https://jq.qq.com/?_wv=1027&k=5YJFXyf'>691892901</a>。本教程仅算盲人摸象的业余分析，仅具备业余参考价值，入门先看x264视频压缩教程综合版。手头需要编码压制不妨搭配急用版教程</p>
            <p class="text-gray-side text-red-emph">点击图片即可更改桌面和移动端的适配排版</p>

            <h3>ffmpeg，VapourSynth，avs2yuv 传递参数</h3>
            <ul class="list-dotless text-gray-side">
                <li class="mt-3">ffmpeg -i &lt;源&gt; -an -f yuv4mpegpipe -strict unofficial - | x265 --y4m - --output</li>
                <li class="text-gray-note mt-3">ffmpeg -i &lt;源&gt; -an -f rawvideo	- | x265.exe --input-res &lt;宽x高&gt; --fps &lt;整/小/分数&gt; - --output</li>
                <li class="mt-3"><span class="text-blue-emph">-f</span>格式，<span class="text-blue-emph">-an</span>关音频，<span class="text-blue-emph">-strict unofficial</span>关格式限制，<span class="text-blue-emph">--y4m</span>对应"YUV for MPEG"，两个"-"是Unix pipe串流</li>
                <li class="mt-3">VSpipe	源.vpy --y4m - | x265.exe - --y4m --output</li>
                <li class="mt-3">avs2yuv	源.avs -csp&lt;色&gt; -depth&lt;深&gt; - | x265.exe --input-res &lt;宽x高&gt; --fps &lt;整/小/分数&gt; - --output</li>
                <li class="mt-3">avs2pipemod 源.avs -y4mp | x265.exe --y4m - --output</li>
            </ul>

            <table>
                <tr>
                    <td><h4 class="m-0">搜索 ffmpeg 支持的色度采样:</h4></td>
                    <td class="text-gray-side">ffmpeg -pix_fmts | findstr &lt;或grep关键字&gt;</td>
                </tr>
                <tr>
                    <td><h4 class="m-0">检查/选择色深，版本，编译:</h4></td>
                    <td class="text-gray-side">x265.exe -V，-D &lt;8/10/12调整色深&gt;</td>
                </tr>
                <tr>
                    <td><h4 class="m-0">多字体+艺术体+上下标 .ass 字幕渲染:</h4></td>
                    <td class="text-gray-side">ffmpeg -filter_complex "ass='F\:/字幕.ass'"滤镜</td>
                </tr>
                <tr>
                    <td><h4 class="m-0">Linux Bash 报错导出:</h4></td>
                    <td class="text-gray-side">x265.exe [命令行] 2>&1 | tee home\[用户名]\Desktop\报错.txt</td>
                </tr>
                <tr>
                    <td><h4 class="m-0">Mac Terminal 报错导出:</h4></td>
                    <td class="text-gray-side">x265.exe [命令行] 2>&1 | tee User\[用户名]\Desktop\报错.txt</td>
                </tr>
                <tr>
                    <td><h4 class="m-0">Windows CMD 报错导出:</h4></td>
                    <td class="text-gray-side">x265.exe [命令行] 2> [桌面路径]\报错.txt</td>
                </tr>
            </table>

            <h2>分块</h2>
            <p>hevc中，帧下结构按面积大小分为<span class="text-blue-emph">帧 → 瓦 tile → 条带 slice → 条带分段 ss → ctu 树单元 → cu 单元</span>.</p>
            <p>cu，cb 由同帧的 ctu 经动态搜索ME与运动补偿MC隔离所得。其U/unit代表YCbCr整体块；B/block则单指Y，Cb或Cr块，区分亮度色度。ipcm-cu 代表跳过 MEMC，直达环路滤波的「帧内编码 pcm 波形 cu」intra pulse code modulation cu，因为“块”是一串像素值的波形，只是用元数据“换行”到二维而已。</p>
            <div class="align-items-center">
                <img src="files/image1.png" alt="Coding Tree Unit" class="img-medium" >
                <p class="text-gray-side mt-0">图：Coding Tree Unit以及其下Coding Unit的划分</p>
            </div>

            <h4 class="same-line">PU - 预测单元:</h4>
            <p class="same-line">prediction unit 是编码完，用做参考源的块。支持cu上对称 rectangle，非对称asymmetric 划分，以更好的隔离动静态。亮度与色度上的分裂法可以不同，小至4x4像素。</p>
            <div class="align-items-center">
                <img src="files/image2.png" alt="Prediction Unit" class="img-medium" >
                <p class="text-gray-side mt-0">图：pu的4种对称rectangular和4种不对称asymmetric划分</p>
            </div>
            
            <h4 class="same-line">TU - 变换单元:</h4>
            <p class="same-line">transformation unit 的划分与 CU 而非 PU 同步，实现变换和量化</p>
            <div class="align-items-center">
                <img src="files/image3.png" alt="Transform Unit" class="img-medium" >
            </div>

            <h4 class="same-line">AU - 存取单元:</h4>
            <p class="same-line">access unit，解码端用于启动解码播放的块，一般为 IDR-AU</p>

            <pre><code>
<b>--ctu</b>&lt;64/32/16，默认64&gt;编码树单元最大大小。大则有损压缩效率高，速度慢。一般建议保持默认，除非片有类似jpeg边缘损失的老片设<span class="text-blue-emph">32</span>，分辨率特别小的老片设<span class="text-blue-emph">16</span>
<b>--min-cu-size</b>&lt;32/16，默认8&gt;限制最小cu大小，简化计算步骤，因为使往后步骤pu，tu的划分也会更大。用多一点码率换取编码速度的参数。建议日常环境使用<span class="text-blue-emph">16</span>或快速编码环境使用<span class="text-blue-emph">32</span>
<b>--rect --amp</b>&lt;开关，默认关，受limit-modes限制，<span class="text-red-emph">amp需rect</span>&gt;限制最小cu大小，简化计算步骤，因为使往后步骤pu，tu的划分也会更大。用多一点码率换取编码速度的参数。建议日常环境使用<span class="text-blue-emph">16</span>或快速编码环境使用<span class="text-blue-emph">32</span>
            </code></pre>

            <h2>变换</h2>
            <div class="row">
                <div id="LR-UD-001" class="col-8">
                    <h4>一维傅里叶变换 1D Fourier Transform</h4>
                    <p>给出与原信号波形等高，从最长的频率周期开始不断缩窄（周期增加）并根据源信号调整相位的参考余弦。在参考余弦波变化的过程中，记下两条波形吻合度变化的曲线-不同波形周期的振幅，得频域信号。反过来将频域所对应的波形加回去就是逆变换。为将源波形中反相（上下颠倒）的余弦也考虑在内，所以计算过程含取立方转正。</p>
                    <p>
                        「不断缩窄的参考余弦」可用
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <mi> cos </mi>
                            <mrow>
                                <mo> ( </mo><mi> x </mi>
                                <mfrac>
                                    <mrow>
                                        <mn> 2 </mn>
                                        <mi> &#x03C0; <!-- greek pi --> </mi>
                                    </mrow>
                                    <mrow>
                                        <mi> T </mi>
                                    </mrow>
                                </mfrac>
                                <mo> ) </mo>
                            </mrow>
                        </math>
                        表示，以及复数用
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <mi> cos </mi>
                            <mrow>
                                <mo> ( </mo><mi> x </mi><mo> ) </mo>
                            </mrow>
                            <mo> + </mo><mi> sin </mi>
                            <mrow>
                                <mo> ( </mo><mi> i </mi><mi> x </mi><mo> ) </mo>
                            </mrow>
                        </math>
                        表示，相位可记为
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <msqrt>
                                <mi> F </mi><mi> T </mi>
                                <msup>
                                    <mrow>
                                        <mrow>
                                            <mo> ( </mo><mi> x </mi><mo> ) </mo>
                                        </mrow>
                                    </mrow>
                                    <mrow>
                                        <mn> 2 </mn>
                                    </mrow>
                                </msup>
                                <mo> + </mo><mi> i </mi><mi> F </mi><mi> T </mi>
                                <msup>
                                    <mrow>
                                        <mrow>
                                            <mo> ( </mo><mi> x </mi><mo> ) </mo>
                                        </mrow>
                                    </mrow>
                                    <mrow>
                                        <mn> 2 </mn>
                                    </mrow>
                                </msup>
                            </msqrt>
                        </math>
                        以及复数用
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <mi> arctan </mi><mn> 2 </mn>
                            <mrow>
                                <mo> ( </mo><mi> i </mi><mi> F </mi><mi> T </mi>
                                <mrow>
                                    <mo> ( </mo><mi> x </mi><mo> ) </mo>
                                </mrow>
                                <mo> , </mo><mi> F </mi><mi> T </mi>
                                <mrow>
                                    <mo> ( </mo><mi> x </mi><mo> ) </mo>
                                </mrow>
                                <mo> ) </mo>
                            </mrow>
                        </math>
                        ，表示频域点的亮度和位移（二维变换下是旋角）。
                        <br>
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <mi> arctan </mi><mn> 2 </mn>
                            <mrow>
                                <mo> ( </mo><mi> y </mi><mo> , </mo><mi> x </mi><mo> ) </mo>
                            </mrow>
                        </math>
                        代表二轴坐标系统计一圈 360°（2π）的旋角，几何坐标系中同理的
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <msup>
                                <mrow>
                                    <mi> tan </mi>
                                </mrow>
                                <mrow>
                                    <mo> - </mo><mn> 1 </mn>
                                </mrow>
                            </msup>
                        </math>
                        超过180°（π）会归零而不用。详见<a href="https://www.desmos.com/calculator/qpnz9celzf">desmos例1</a>，<a href="https://www.desmos.com/calculator/ywxqicajbv">desmos例2</a>，<a href="https://www.youtube.com/watch?v=spUNpyF58BY">3b1b视频科普</a>以及<a href="https://www.youtube.com/watch?v=tEzgtbnbXgQ">Computer Vision 公开课</a>。
                    </p>
                    <h4>二维傅里叶变换2D-FT</h4>
                    <p>宽高上单拆出线来分别进行1DFT，通过双求和/双积分 ΣΣ/∫∫ 整合。在频域中相当于每个像素的变换结果相加或干涉。亮则振幅大，距中心远则频率高。强在可编辑性，可以消除打印喷头，抖动等均匀噪声。</p>
                </div>
                <img src="files/image4.png" alt="Fourier Transform Phenomenons" id="LR-UD-002" class="img-medium img-right col-4 mb-auto" >
                <div id="LR-UD-003" class="col-8">
                    <h4>二维离散余弦变换 2D Descrete Cosine Transform</h4>
                    <p>用预制的二维波形模具，穷举加减列出各波形格子的使用次数，实现比2DFT更快的变换。</p>
                    <p class="text-gray-side mt-0">图：二维傅里叶变换的特性，背景特性以及可编辑性</p>
                </div>
                <img src="files/image5.png" alt="Fourier Transform Editing" id="LR-UD-004" class="img-medium img-right col-4 mb-auto" >
            </div>

            <pre class="m-0"><code>
<b>--limit-tu</b>&lt;整数0~4默认关，<span class="text-red-emph">需tu-intra/inter-depth大于1</span>&gt;提前退出tu分块，以量化/残差编码质量为代价提速。<a href="https://forum.doom9.org/showthread.php?p=1963250#post1963250">tu大则易出现量化涂抹</a>，不利于暂停画质
    · <span class="text-blue-emph">1</span> 一般，画质编码，取分裂/跳过中花费最小的
    · <span class="text-blue-emph">2</span> 以同ctu内的首个tu分裂次数为上限
    · <span class="text-blue-emph">3</span> 快速编码取帧内帧间附近tu分裂平均次数为上限
    · <span class="text-blue-emph">4</span> 不推荐，将3作为未来tu的分裂上限，相比0+20%速度
<b>--rdpenalty</b>&lt;整数0~2，默认关，<span class="text-red-emph">需tu-intra-depth大于1</span>&gt;与limit-tu相反，强制tu分块细化以增加算力损耗并降低量化涂抹。可理解为tu分块的下限，例如高limit-tu，高crf时设2，避免32x32tu量化效果太强画面糊掉
    · <span class="text-blue-emph">1</span> 提高率失真代价而减少32x32tu出现概率
    · <span class="text-blue-emph">2</span> 强制32x32tu分块
    · <span class="text-red-emph">32x32的帧内cu需tu-intra-depth 2</span>
    · <span class="text-red-emph">64x64帧内cu需tu-intra-depth 3</span>
<b>--tu-intra-depth --tu-inter-depth</b>&lt;整数1~4，默认1，<span class="text-blue-emph">配合limit-tu</span>&gt;空间域tu分裂次数上限,默认只在cu基础上分裂一次。决定量化质量所以建议开高，建议一般情况设2，保画质设3~4
<b>--max-tu-size</b>&lt;32/16/8/4，默认32&gt;大tu使压缩高而慢，以及瑕疵检测能力越差。码率换时间加画质。编码已有边缘损失的老片可搭配<span class="text-blue-emph">ctu 32</span>与<span class="text-blue-emph">max-tu-size 16</span>
            </code></pre>

            <h2>帧间-动态搜索</h2>
            <p>逐块于帧间找最小失真朝向 Direction of minimal distortion / DMD，组成一张张帧间矢量表。缺则参考帧与分块的建立就不甚理想，损失可能的压缩率或画质。</p>
            <div class="align-items-center">
                <img src="files/image6.png" alt="Jain&Jain Search" class="" >
                <p class="text-gray-side mt-0">图：传统的 Jain & Jain 十字搜索。</p>
                <img src="files/image7.png" alt="LDSP&SDSP Search" class="" >
                <p class="text-gray-side mt-0">图：大小菱搜索。x264/5中，六边形搜索me hex将LDSP的上下左右斜8个外点减到6个，SDSP的细化规则不变。</p>
                <img src="files/image8.png" alt="Uneven multi-hexagon Search" class="" >
                <p class="text-gray-side mt-0">图：umh搜索。</p>
            </div>

            <pre><code>
<b>--analyze-src-pics</b>&lt;开关，默认关&gt;允许动态搜索查找片源帧，耗时增加压缩
<b>--me</b>&lt;hex/umh/star/esa/full，推荐umh&gt;搜索算法，umh平衡，star四角星搜索之后收益递减，sea是优化过的x264 esa穷举，但收益递减仍大
<b>--merange</b>&lt;整数，推荐4的倍数，<span class="text-red-emph">需me</span>&gt;<span class="text-blue-emph">完全取决于ME算法和分辨率</span>，过大会因「找不到更好，找到也是错」而损失画质和压缩
    · 1920x1080下推荐<span class="text-blue-emph">48</span>左右
    · 3840x2160下推荐<span class="text-blue-emph">52</span>左右
    · me hex下设<span class="text-blue-emph">16</span>
    · me umh-star设<span class="text-blue-emph">≥32</span>
<b>--no-temporal-mvp</b>&lt;开关&gt;关P-B条带的动态搜索，除直播外不推荐
<b>--hme-search</b>&lt;hex/umh/star/esa/full，<span class="text-red-emph">关me</span>&gt;三份异分辨率原画分别查找宏观到微观的搜索动态信息
<b>--hme-range</b>&lt;三整数，<span class="text-red-emph">需hme-search</span>，推荐默认<span class="text-blue-emph">16,32,48</span>&gt;对应<math xmlns='http://www.w3.org/1998/Math/MathML'><mfrac><mrow><mn> 1 </mn></mrow><mrow><mn> 16 </mn></mrow></mfrac></math>，<math xmlns='http://www.w3.org/1998/Math/MathML'><mfrac><mrow><mn> 1 </mn></mrow><mrow><mn> 4 </mn></mrow></mfrac></math>和全分辨率三画面
            </code></pre>
            
            <h2>帧间-子像素运动补偿</h2>
            <p>动态预测 ME 除了与帧内编码后的帧做差（以便推演P/B/I帧，见x264教程）以外，还被动态补偿 MC 以「允动画之移，拦静画所变」的原理消除如噪点之类导致的动态信息误判，同时将帧间矢量表中动态矢量的精度提高到
            <math xmlns='http://www.w3.org/1998/Math/MathML'>
                <mfrac>
                    <mrow>
                        <mn> 1 </mn>
                    </mrow>
                    <mrow>
                        <mn> 4 </mn>
                    </mrow>
                </mfrac>
            </math>
            像素以修复「动态预测因精度低导致细节损失」的画面错误。</p>
            <p>大体上，补偿过程是用帧内编码所得的“粗加工PU”与源视频对应的块做差，使用有限冲激响应滤镜 Finite impulse response (FIR) filter 放大。此处指 x264-6tap；x265-8tap，7tap 和 4tap 滤镜。放大后用 SATD 对准动态矢量，得“精加工PU”。</p>
            <div class="row">
                <div id="LR-UD-005" class="col-8 align-items-center">
                    <table class="table-center">
                        <tr>
                            <th>编码器</th>
                            <th>平面-块类型</th>
                            <th>范围精度</th>
                            <th>插值方法</th>
                        </tr>
                        <tr class="t-light-gray">
                            <td>x264官方</td>
                            <td>亮度Y</td>
                            <td>½像素（hpel）</td>
                            <td>6tap FIR</td>
                        </tr>
                        <tr>
                            <td>x264官方</td>
                            <td>亮度Y</td>
                            <td>¼像素（qpel）</td>
                            <td>双线性插值（Bi-lerp）</td>
                        </tr>
                        <tr class="t-light-gray">
                            <td>x264官方</td>
                            <td>色度C</td>
                            <td>hpel+qpel</td>
                            <td>上下左右加权平均</td>
                        </tr>
                        <tr>
                            <td>x265官方</td>
                            <td>亮度Y</td>
                            <td>hpel+qpel</td>
                            <td>上下左右加权平均</td>
                        </tr>
                        <tr class="t-light-gray">
                            <td>x265官方</td>
                            <td>亮度Y</td>
                            <td>¼像素（qpel）</td>
                            <td>两种7tap FIR</td>
                        </tr>
                        <tr>
                            <td>x265官方</td>
                            <td>色度C</td>
                            <td>hpel+qpel</td>
                            <td>4tap FIR</td>
                        </tr>
                    </table>
                </div>
                <img src="files/image9.png" alt="hpel qpel interpolation" id="LR-UD-006" class="img-medium img-right col-4 mb-auto" >
            </div>
            <p class="text-gray-side mt-0">表：x264/5实现h~qpel插值计算（实现了浮点→整数变量的程序优化）</p>
            <p class="text-gray-side mt-0">图：此“子像素”特指是放大出的half-pixel(hpel)
            <math xmlns='http://www.w3.org/1998/Math/MathML'>
                <mfrac>
                    <mrow>
                        <mn> 1 </mn>
                    </mrow>
                    <mrow>
                        <mn> 2 </mn>
                    </mrow>
                </mfrac>
            </math>
            像素，及quarter-pixel(qpel)
            <math xmlns='http://www.w3.org/1998/Math/MathML'>
                <mfrac>
                    <mrow>
                        <mn> 1 </mn>
                    </mrow>
                    <mrow>
                        <mn> 4 </mn>
                    </mrow>
                </mfrac>
            </math>
            像素。</p>
            
            
            <div class="align-items-center">
                <img src="files/image10.png" alt="7tap 8tap interpolation 1" class="img-medium" >
            </div>
            <p class="text-gray-side mt-0">图：Y平面FIR插值和subme并行，调用8²或16²块的横/纵向参考源。若subme所得动态的:</p>
            <ul>
                <li class="text-gray-side">向量横分量==0: [d][n]分别用7tapα或β采样整像素[A]</li>
                <li class="text-gray-side">向量横分量!=0: [f][q]分别用7tapα或β采样子像素[b]</li>
                <li class="text-gray-side">向量纵分量==0: [a][c]分别用7tapα或β采样整像素[A]</li>
                <li class="text-gray-side">向量纵分量!=0: [i][k]用8tap分别采样子像素[a][c]</li>
            </ul>
            <div class="align-items-center">
                <img src="files/image11.png" alt="7tap 8tap interpolation 2" class="img-medium" >
            </div>

            <pre><code>
<b>--subme</b>&lt;整数范围1~7，默认2&gt;根据源帧率借下表判断。
注：x264的rdo选项和subme并用，所以与x265不通用；SATD算法见x264教程。
            </code></pre>
            <div class="align-items-center mt-3">
                <table class="table-center">
                    <tr>
                        <th>范围（率失真优化开）</th>
                        <th>推荐</th>
                        <th>hpel迭代</th>
                        <th>hpel搜索</th>
                        <th>qpel迭代</th>
                        <th>qpel搜索</th>
                        <th>统计法</th>
                    </tr>
                    <tr class="t-light-gray">
                        <td>30fps</td>
                        <td class="text-blue-emph">3</td>
                        <td>2次</td>
                        <td>4方向</td>
                        <td>1次</td>
                        <td>4方向</td>
                        <td>SATD</td>
                    </tr>
                    <tr>
                        <td>48fps</td>
                        <td class="text-blue-emph">4</td>
                        <td>2次</td>
                        <td>4方向</td>
                        <td>2次</td>
                        <td>4方向</td>
                        <td>SATD</td>
                    </tr>
                    <tr class="t-light-gray">
                        <td>60fps</td>
                        <td class="text-blue-emph">5</td>
                        <td>1次</td>
                        <td>8方向</td>
                        <td>1次</td>
                        <td>8方向</td>
                        <td>SATD</td>
                    </tr>
                    <tr>
                        <td>90fps</td>
                        <td class="text-blue-emph">6</td>
                        <td>2次</td>
                        <td>8方向</td>
                        <td>1次</td>
                        <td>8方向</td>
                        <td>SATD</td>
                    </tr>
                    <tr class="t-light-gray">
                        <td>≥144fps</td>
                        <td class="text-blue-emph">7</td>
                        <td>2次</td>
                        <td>8方向</td>
                        <td>2次</td>
                        <td>8方向</td>
                        <td>SATD</td>
                    </tr>
                </table>
            </div>

            <h4>加权预测 Weighted Prediction</h4>
            <div class="row">
                <div id="LR-UD-007" class="col-10">
                    <p>解决淡入淡出 fade 过程中，部分 PU 因误参考，亮度变化不一的块失真问题；分为 P-B 条带用的显加权，和 B 条带用的隐加权。</p>
                    <ul class="text-gray-side">
                        <li>显Explicit：原画和编码过的参考帧做差，差距越小权重越高</li>
                        <li>隐Implicit：用参考帧距离做加权平均插值，距离越近权重越高</li>
                    </ul>
                </div>
                <img src="files/image12.png" alt="Implicit Weighted Prediction" id="LR-UD-008" class="img-small img-right col-2 mt-3 mb-auto" >

                <pre><code>
<b>--weightb</b>&lt;开关，默认关&gt;启用B条带的隐加权预测。注意光线变化和淡入淡出在公开课，电脑录屏，低成本/旧动漫等片源中几乎不存在，这种情况下打开只会浪费性能
                </code></pre>
            </div>

            <h2>帧间-时域架网搜索</h2>
            <h4>一维小波变换 1D Wavelet Transform</h4>
            <p>让短波像拉链一样划过一维信号，时间轴上根据短波波形选择，将与源信号匹配的程度变化记为频域信息（如使用低频-高频-低频的对称波形拆出音频热度图），支持更换波形以提取特征（如特征采样式音频降噪滤镜）。解决了傅里叶变换只有空间频域，无法描述信号随时间变化过程的原生缺陷，缺点是分辨率低。</p>
            
            <h4>基于提升式小波变换的时域动态补偿 lifting-scheme temporal MC</h4>
            <div class="row">
                <div id="LR-UD-009" class="col-auto">
                    <p>类似于 crf/abr 模式推演量化值中以 a-b 帧之差做复杂度累计。此处是用以预测 b-c 帧的差，而<span class="text-blue-emph">预测对的更新到低频L带，差错的更新到（不再参与下轮预测）的高频H带</span>，得 0-1-2，2-3-4，4-5-6 等（prediction）帧以及其 H 带（update）构成第 0 层</p>
                    <p>继续在 L<sub>1</sub>→L<sub>n</sub> 的1层向右迭代，分离出所有的 L，H 带，如此实现迭代 n 次即分离 2<sup>n</sup> 帧动静态，以及所有的预测与补偿，故不像传统动态搜索一样受缩放性 scalability（分辨率 vs 搜索范围）限制。是 Scalable Video Codec - SVC 编码的核心算法之一。</p>
                    <p>迭代后的高低频用 LL<sub>1</sub> LL<sub>2</sub> LH<sub>1</sub> LH<sub>2</sub> 表示低到高频的顺序，字母位数代表迭代次数。</p>
                </div>
                <img src="files/image13.png" alt="Lifting Scheme Temporal Motion Compensation" id="LR-UD-010" class="img-right col-auto mb-auto" >
            </div>

            <h4>高斯模糊 Gaussian blur</h4>
            <p>利用正态分布函数面积不变的特性，通过设定偏差程度 σ 决定正态分布钟的梯度：σ 大则钟扁——滤镜中心分到的权重/面积越被更多分到权/面积的旁像素冲淡模糊掉，设计行业常用。见<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A">维基百科</a>和<a href="https://www.desmos.com/calculator/jxzs8fz9qr">Desmos互动例</a>。</p>
            <div class="align-items-center">
                <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                    <mi> G </mi>
                    <mrow>
                        <mo> ( </mo><mi> x </mi><mo> ) </mo>
                    </mrow>
                    <mo> = </mo>
                    <mfrac>
                        <mrow>
                            <mn> 1 </mn>
                        </mrow>
                        <mrow>
                            <msqrt>
                                <mn> 2 </mn>
                                <mi> &#x03C0; <!-- greek pi --> </mi>
                                <msup>
                                    <mrow>
                                        <mi> &#x03C3; <!-- greek sigma --> </mi>
                                    </mrow>
                                    <mrow>
                                        <mn> 2 </mn>
                                    </mrow>
                                </msup>
                            </msqrt>
                        </mrow>
                    </mfrac>
                    <msup>
                        <mrow>
                            <mi> e </mi>
                        </mrow>
                        <mrow>
                            <mo> - </mo>
                            <mfrac>
                                <mrow>
                                    <msup>
                                        <mrow>
                                            <mi> x </mi>
                                        </mrow>
                                        <mrow>
                                            <mn> 2 </mn>
                                        </mrow>
                                    </msup>
                                </mrow>
                                <mrow>
                                    <mn> 2 </mn>
                                    <msup>
                                        <mrow>
                                            <mi> &#x03C3; <!-- greek sigma --> </mi>
                                        </mrow>
                                        <mrow>
                                            <mn> 2 </mn>
                                        </mrow>
                                    </msup>
                                </mrow>
                            </mfrac>
                        </mrow>
                    </msup>
                </math>
            </div>
            <h4>中值滤镜median filter</h4>
            <p>和卷积滤镜一样用n×n的滤镜格子逐像素扫图，区别在于滤镜中心会被替换为旁像素的中值。如此一来在扫描窗口任意两端几乎一致的像素值会被识别为线段或边缘，中间的像素值会被同化，而平面上的噪点/颗粒就会被抹除，生成仅有平/斜面和完整线条边缘的“模糊”结果。见<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8">维基百科</a>。</p>
            <h4>双边滤镜bilateral filter</h4>
            <p>将中值滤镜输出作为（2D）高斯模糊的权重蒙版（通过矩阵点除实现动态干涉滤镜强度）；因此平面/斜面/线条本身会决定高斯模糊正态分布钟在对应位置被保留/干涉/隔断的程度</p>
            <img src="files/image14.png" alt="Bilateral Filter" class="" >

            <pre><code>
<b>--mcstf</b>&lt;开关，默认关，<span class="text-red-emph">会关多线程</span>&gt;时域动态补偿滤镜mctf搭配双阈滤镜的自动降噪，理论上提高细节保真。关多线程会大幅削弱性能
            </code></pre>

            <h2>溯块向量搜索</h2>
            <p>与帧内编码并行给动态搜索提供溯块向量（cu帧内/帧间朝向以及大小）的步骤。由于移动的物件会跨越多个 PU ，所以将涉及同个移动物件的 PB 合到一起就能冗余一群 PB 的动态向量。x264/5 用 <span class="text-blue-emph">--ref</span> 参数于时域上划区，逐 PU 创建 L<sub>0</sub> 和 L<sub>1</sub> 左右两排参考列表。x265 在 x264 <span class="text-blue-emph">--direct auto</span> 的基础上添加了 AMVP 与 Merge mode 两个方案</p>

            <h4>高级动态向量搜索 Advanced Motion Vector Prediction</h4>
            <ol class="mt-0">
                <li>在帧内看当前 PU 左下的邻 PU，优先匹配向量往帧内指的邻 PU</li>
                <li>参考向量指向其它帧的临 PU；并等比缩放，对齐到邻 PU 已按帧间差异对齐好的向量</li>
                <li>若以上步骤没找到参选向量，就把同样的步骤于当前 PU 右上角进行一次</li>
                <li>若应了如早批 PU 刚开始算，找不到参选向量的情况下就直接从时域搜索：<ul>
                    <li class="text-gray-side">照帧间参考图像变化的内容差异做缩放调整，从右下角的相邻 PU 找参选</li>
                </ul></li>
                <li>若仍不可用，就找当前 PU 中心位置的其它同位 PU；若最后没凑不齐两个参选向量，代入v=0,0</li>
            </ol>
            <div class="row">
                <h4>并和搜索模式 Merge Mode</h4>
                <p id="LR-UD-011" class="col-8">然后用相对简单含糊算法接手剩余块的向量：从帧间，帧内凑五个参选块 candidate，两个备选，少服从多地并和动态向量。（该模式会跳过PU的边缘及当前向量以提速）</p>
                <img src="files/image15.png" alt="HEVC Merge Mode" id="LR-UD-012" class="img-medium img-right col-4 mb-auto" >
            </div>

            <pre><code>
<b>--max-merge</b>&lt;整数0~5，默认2&gt;重设merge mode被选参考块的数量，时间换质量。建议高压编码设<span class="text-blue-emph">4</span>，其它可设<span class="text-blue-emph">2，3</span>
<b>--early-skip</b>&lt;开关，默认关&gt;先查2nx2n merge被选块，找不到就跳过AMVP以提速
            </code></pre>

            <h2>初始化-Lookahead</h2>
            <p>最先运行，给视频帧分段并最终整合成 GOP 内树叉状的参考结构，设关键帧并递给下一步帧内编码。一来冗余，二来防止参考错误蔓延（否则丢一个网络数据包会导致长时间绿屏花屏）。过程见<a href="https://www.nazorip.site/archives/63">x264教程</a></p>

            <pre><code>
<b>--scenecut</b>&lt;整数，不推荐用&gt;Lookahead中两帧差距达到该参数值则触发转场
<b>--hist-scenecut</b>&lt;开关，默认关，会关scenecut，<span class="text-blue-emph">10与12bit源可能会导致崩溃</span>，推荐8bit下用&gt;亮度平面边缘+颜色直方图SAD阈值触发转场。x265 v3.5+69后编码彩色视频，尤其<a href="https://forum.doom9.org/showthread.php?p=1978502">HDR源中超越scenecut精度~20%</a>，降低了正误判（设I帧，closed-gop下帧间冗余效益降低）和负误判（不设I帧，分为多个带I块的P帧，帧内编码效益降低），因此除黑白视频外推荐。缺点是超过8bit后不稳定，且理论上不应对画质/压缩率有太大影响
注：hist-threshold参数于x265 v3.5+69被删
<b>--rc-lookahead</b>&lt;帧数量，范围1~250，推荐keyint÷2&gt;指定cutree的检索帧数，通常设在帧率的2.5~3倍。高则占用内存增加延迟，低则降低压缩率和平均画质。
注：cutree会自动选择--rc-lookahead和max(--keyint,max(--vbv-maxrate,--bitrate)÷--vbv-bufsize×fps)中最小的值作为检索帧数
<b>--no-cutree</b>&lt;开关&gt;关闭少见CTU量化增强偏移。可能只有近无损，crf小于16才用的到
            </code></pre>

            <h4 class="same-line">P/B帧推演-Viterbi最短路径算法</h4><p class="same-line">：见<a href="https://www.nazorip.site/archives/63">x264教程</a></p>

            <pre><code>
<b>--b-adapt</b>&lt;整数0~2，推荐<span class="text-blue-emph">2</span>&gt;<span class="text-blue-emph">0</span>停用，<span class="text-blue-emph">1</span>快速算法，因当今设备算力够高所以一律<span class="text-blue-emph">2</span>
<b>--bframe-bias</b>&lt;整数-90~100，推荐默认&gt;设立B帧判定偏移，增大的同时搭配低pbratio可增加B帧数量，用负值搭配高pbratio可以减少B帧数量
            </code></pre>

            <h4>网络抽象层单元-参数集</h4>
            <p>Network abstraction layer unit 中含解码配置 profile，level 的数据包。x264 中的视频帧数即 <span class="text-blue-math">sps->vui.i_num_units_in_tick</span> 或 <span class="text-blue-math">sps->vui.i_time_scale÷2</span> 所得（÷1则为分行交错视频）</p>
            <ul class="text-gray-side">
                <li>视频参数集video parameter set</li>
                <li>序列参数集sequence parameter set——-分枝-负责播放时间戳，显加权与其它特定解码要求</li>
                <li>图参数集picture parameter set————分枝-负责解码信息</li>
                <li>条带段slice segment—————————分枝-负责防止ctu中的错误传播到整个条带，ctu以上最小的单位</li>
            </ul>

            <pre><code>
<b>--opt-qp-pps --opt-ref-list-length-pps</b>&lt;开关，默认关，已知兼容性问题&gt;据上个GOP改动当前PPS中默认的qp/ref参数值，从而整体上优化视频数据结构。尽管符合HEVC标准，但部分解码端，包括视频网站都不这么想
注：兼容性问题为<a href="https://forum.doom9.org/showthread.php?p=1978837">应该用hev1而非hvc1封装进ISO-BMFF</a>
<b>--repeat-headers</b>&lt;开关, 默认关&gt;在流未封装的情况下提供SPS，PPS等信息，正常播放HEVC源码
注：封装文件的科普<a href="https://www.nazorip.site/archives/63">见x264教程</a>
            </code></pre>

            <h4>流媒体缓冲缓存</h4>
            <p>视音频在开始播放前预先加载到内存的一段缓冲区。只要存入缓冲区的波动不大就能保证播放在很多条件下的流畅性。视频流则以确保网络设施正常和控制视频码率本身做到流畅</p>

            <h4>Videl Buffer Verifier - 基于缓冲条件的量化控制</h4>
            <p>手动指定网络/设备下所允许的缓冲速度 kbps 以加大量化压缩，控制 CRF/ABR 模式。与 CRF 一并使用时叫可变码率 Variable Bitrate / VBR 模式。使用时应注意 VBV 完全不理画质，而卡顿的原因可能仅仅是因为 app 客户端的缓存设太小了。</p>

            <pre><code>
<b>--vbv-bufsize</b>&lt;整数kbps，默认关=0，<span class="text-red-emph">小于maxrate</span>&gt;编码器解出原画后，最多可占的缓存每秒。bufsize÷maxrate=播放时解码出每gop原画帧数的缓冲用时（秒）。<span class="text-blue-emph">值的大小相对于编完GOP平均大小。编码器用到是因为模式决策要解码出每个压缩步骤中的内容与原画作对比用</span>
<b>--vbv-maxrate</b>&lt;整数kbps，默认关0&gt;峰值红线。用「出缓帧码率-入缓帧码率必≤maxrate"」限制编码器在GOP码率超bufsize，即缓存跑满时压缩超载帧（提高qp值+强降噪至码率合规为止）。当入缓帧较小时，出缓帧就算超maxrate也会因缓存有空而不被压缩。所以有四种状态，需经验判断：
    · 大：GOP大小=bufsize=2×maxrate，超限后等缓存满再压，避开多数涨落，适合限平均率的串流
    · 小：GOP大小=bufsize=1×maxrate，超码率限制后直接压，避开部分涨落，适合限峰值的串流
    · 超：GOP大小&lt;bufsize=1~2×maxrate，超码率限制后直接压，但因视频小/crf大所以没啥作用
    · 欠：GOP大小&gt;bufsize=1~2×maxrate，超码率限制后直接压，但因视频大/crf小所以全都糊掉
    · 由于gop多样，4种状态常会出现在同一视频中。buf/max实际控制了这些状态的出现概率
<b>--crf-max</b>&lt;整数0~51&gt;防止vbv把crf拉太高，但会导致码率失控
            </code></pre>

            <h4>关键帧</h4>
            <h5>IDR刷新解码帧 instant decoder refresh</h5>
            <ul class="text-gray-side text-smaller">
                <li>自身储存完整图片，但同时还负责GOP间划界分段，播完令解码器清理前GOP缓存的大写I帧</li>
                <li>清缓存是为了防止参考/内存错误传播，错误可能源自硬件/软件/网络/干扰等</li>
            </ul>
            <h5>RAP随机访问点 random access point</h5>
            <ul class="text-gray-side text-smaller">
                <li>“访问”代表播出画面前获取数据的过程</li>
                <li>“任意”代表拖进度条，打开直播，使进度条上任意一点都要正常解码的目的，增加码率提升体验</li>
            </ul>
            <h5>CRA/DRA净/脏任意访问 clean/dirty random access</h5>
            <ul class="text-gray-side text-smaller">
                <li>open-gop状态下指定包括GOP间划界，GOP内帧间参考，自身储存完整图片的i帧</li>
                <li>附近的rasl/radl帧与之相对应</li>
                <li>「脏」指一组含i块的P帧，需要全部解码才能重建出i帧。压缩更高但相比i帧的解码更容易糊（脏）</li>
            </ul>
            <h5>BLA断链访问帧 broken link access</h5>
            <ul class="text-gray-side text-smaller">
                <li class="mt-0">open-gop间划界，访问不相关/不相连GOP的特殊CRA帧。用于不暂停播放的分辨率切换</li>
            </ul>

            <pre><code>
<b>no-open-gop</b>&lt;开关，默认关，建议开&gt;不用cra/bla，增加码率增加兼容性，适合长GOP策略
<b>--keyint</b>&lt;整数，默认25&gt;判断新发现的转场距上个IDR帧的距离是否短于此值。有两种设定逻辑，而它们给出的画质都一样：
    · 设5或更高，省了设立一些IDR帧拖慢速度。快速编码/直播环境直接设=keyint
    · 设1来增加IDR帧，一帧被判做转场本来就意味着前后溯块的价值不高。而P/B帧内可以放置I宏块，x264/5倾向插P/B帧。好处是进度条落点在激烈的动作场面更密集
<b>--fades</b>&lt;开关，默认关&gt;找流中的虚实渐变fade-in，给小到帧间条带，大到整个帧间范围改用I条带，并根据渐变后最亮的帧重设码率控制历史记录，解决转场致模糊的问题
注：与weightb殊路同归但效果更强，增加码率更多
            </code></pre>

            <h4>参考帧</h4>
            <h5>RASL 任访略前导，RADL 任仿解前导 random access skipping/decoding lead</h5>
            <ul class="text-gray-side text-smaller">
                <li>打开直播或用户拖动进度条落在CRA附近，找不到I帧时指定应该解码decode还是略过skip的标签P帧</li>
            </ul>

            <pre><code>
<b>--ref</b>&lt;整数1~16，推荐<span class="text-blue-math">fps÷100+3.4</span>&gt;向量溯块前后帧数半径，一图流设<span class="text-blue-emph">1</span>. 要在能溯全所有块的情况下降低参考面积，所以一般设<span class="text-blue-emph">3</span>就不管了
<b>--radl</b>&lt;整数默认0，小于连续B帧，推荐2~3&gt;原理见上
<b>--ipratio --pbratio</b>&lt;浮点,默认1.4 1.3&gt;P帧比IDR/I，及B/b帧相比P帧的量化值递增。B帧双向参考能从更多帧中找到参考源，因此量化强度理应最高：
    · 真人录像片源中保持默认
    · 动漫片源中连续长B帧出现几率增多，有时会找不到合适的参考源导致画质损失，用<span class="text-blue-emph">1.2</span>或更小分配一定码率
    · 可据比例换算帧类型的qp，如<span class="text-blue-emph">I-qp17</span>，<span class="text-blue-emph">P-qp20</span>，<span class="text-blue-emph">B-qp22</span>即<span class="text-blue-emph">--qp/crf 17 --ipratio 1.1765 --pbratio 1.1</span>
<b>--bframes</b>&lt;整数0~16&gt;最多可连续插入的B帧数量：
    · 一般录像/录屏快速，以及视频剪辑素材设<span class="text-blue-emph">3~6</span>以防止录制和剪辑的解码算力要求过高
    · 电影片源快速设<span class="text-blue-emph">8</span>左右
    · 低成本动画片源，或播放设备配置或硬解兼容高的话可设在<span class="text-blue-emph">13</span>左右
注：bframes大于8，同时keyint大于250会大增内存占用，但也取决于视频分辨率
            </code></pre>

            <h2>帧内编码</h2>
            <div class="row">
                <div id="LR-UD-013" class="col-8">
                    <p>组成参考源（I帧）+参考帧的帧间结构后，数据会集中到 I帧/ I块上。故先使用单图无损压缩——补偿参考源，平滑（3-tap/ss），和编码 PB（趋平/夹角/DC）三步。补偿解决 PB 位于边角，或等不到其它 CB 编码完成而缺失的参考源；平滑预处理即根据情况，选择 3-tap FIR 或强力平滑滤镜，卷积插值出「纯预测 PU」</p>
                    <p>以下图预测块 C 为例：缺编码块B处的参考源就用编码块 A 的最右存在参考源做副本，并如法炮制编码块 D 补充 A-B 两块参考源的逻辑；EDAB 四编码块皆缺，则拿编码块 F 的顶部参考源替代；否则参考源皆填像素中值</p>
                    <p class="text-gray-side mt-0">图：补充参考源的检查顺序。</p>
                </div>
                <img src="files/image16.png" alt="HEVC Merge Mode" id="LR-UD-014" class="img-medium img-right col-4 mb-auto" >
    
                <div id="LR-UD-015" class="col-8">
                    <h4>强力平滑滤镜的启用条件</h4>
                    <ol>
                        <li>预测块 C 的大小小于 32x32</li>
                        <li>底-中-顶，及左-中-右三个纵/横向参考源两两差之和小于视频位深，如 8bit 下为 8</li>
                        <li>非 DC，非平行（夹角 10），非垂直（夹角 26）的帧内编码模式</li>
                    </ol>
                    <p class="text-gray-side mt-0">图：强力平滑滤镜的启用条件。</p>
                </div>
                <img src="files/image17.png" alt="Strong Intra Smoothing Condition" id="LR-UD-016" class="img-medium img-right col-4 mb-auto" >
                
                <div id="LR-UD-017" class="col-8">
                    <h4>强力平滑滤镜 Strong intra smoothing</h4>
                    <ol>
                        <li>从横-纵向两个参考点直接线性插值 lerp 出所有参考点，以及所对应的预测像素 p</li>
                        <li>缓解了色带问题</li>
                    </ol>
                    <p class="text-gray-side mt-0">图：强力平滑滤镜。</p>
                </div>
                <img src="files/image18.png" alt="Strong Intra Smoothing Filter" id="LR-UD-018" class="img-medium img-right col-4 mb-auto" >
                
                <div id="LR-UD-019" class="col-8">
                    <h4>3-tap 有限冲击响应 Finite Impulse Reponse 滤镜</h4>
                    <p>用横向
                    <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                        <mi> t </mi>
                        <mrow>
                            <mo> ( </mo><mi> x </mi><mo> ) </mo>
                        </mrow>
                    </math>
                    与纵向
                    <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                        <mi> l </mi>
                        <mrow>
                            <mo> ( </mo><mi> y </mi><mo> ) </mo>
                        </mrow>
                    </math>
                    各3像素加权平均得预测像素 p，按卷积顺序轮询得到 PU</p>
                    <p class="text-gray-side mt-0">图：3tap FIR滤镜。</p>
                    <p>预处理后，用趋平，夹角，或 DC 模式初步编码 PB 到 CB。</p>
                </div>
                <img src="files/image19.png" alt="3tap FIR Filter" id="LR-UD-020" class="img-small img-right col-2 mb-auto" >

                <h4>趋平模式Planar</h4>
                <div id="LR-UD-021" class="col-8">
                    <p>用双线性插值 Bi-lerp，让左-上过渡为右-下平面。由<span class="text-blue-math"><span class="text-blue-pure">底β</span>×<span class="text-blue-pure">高α</span>+<span class="text-red-pure">底α</span>×<span class="text-red-pure">高β</span>=<span class="text-green-pure">h</span>×<span class="text-green-pure">底γ</span></span>的关系得过渡线<math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                        <mi> h </mi>
                    </math>
                    ，
                    <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                        <mi> t </mi>
                        <mrow>
                            <mo> ( </mo><mi> x </mi><mo> , </mo><mi> y </mi><mo> ) </mo>
                        </mrow>
                    </math>
                    再做一遍得过渡线
                    <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                        <mi> v </mi>
                        <mrow>
                            <mo> ( </mo><mi> x </mi><mo> , </mo><mi> y </mi><mo> ) </mo>
                        </mrow>
                        <mo> , </mo><mi> h </mi>
                        <mrow>
                            <mo> ( </mo><mi> x </mi><mo> , </mo><mi> y </mi><mo> ) </mo>
                        </mrow>
                    </math>
                    ；
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <mi> v </mi>
                            <mrow>
                                <mo> ( </mo><mi> x </mi><mo> , </mo><mi> y </mi><mo> ) </mo>
                            </mrow>
                        </math>
                    取平均得预测像素
                    <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                        <mi> p </mi>
                    </math>
                    。</p>
                    <p class="text-gray-side mt-0">图：得到一个平均预测像素p(x,y)的过程。</p>
                </div>
                <img src="files/image20.png" alt="Planar Intra Coding Mode" id="LR-UD-022" class="img-small img-right col-4 mb-auto" >

                <h4>夹角模式 Direct（35种）</h4>
                <div id="LR-UD-023" class="col-8">
                    <p>将渐变（斜面）PB 无损压缩为编码块 CB 中全部画面与参考源共角的夹角
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <mi> &#x03B8; <!-- greek theta --> </mi>
                        </math>
                        拓补结构。通过穷举所有
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <mi> p </mi>
                            <mrow>
                                <mo> ( </mo><mi> x </mi><mo> , </mo><mi> y </mi><mo> ) </mo>
                            </mrow>
                        </math>
                        的夹角以尝试对齐上方横向参考源
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <mi> t </mi><mo> ( </mo><mi> x </mi><mo> ) </mo>
                        </math>
                        ，或左侧纵向参考源
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <mi> l </mi><mo> ( </mo><mi> y </mi><mo> ) </mo>
                        </math>
                        中差异最小的点
                        <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                            <mi> t </mi>
                            <mrow>
                                <mo> ( </mo><mi> x </mi><mo> &#x00B1; <!-- plus-minus --> </mo><mi> n </mi><mo> ) </mo>
                            </mrow>
                        </math>
                    或纵向的
                    <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                        <mi> l </mi>
                        <mrow>
                            <mo> ( </mo><mi> y </mi><mo> &#x00B1; <!-- plus-minus --> </mo><mi> n </mi><mo> ) </mo>
                        </mrow>
                    </math>
                    构成直角三角。用三角函数
                    <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                        <mfrac>
                            <mrow>
                                <mi> o </mi><mi> p </mi><mi> p </mi>
                            </mrow>
                            <mrow>
                                <mi> a </mi><mi> d </mi><mi> j </mi>
                            </mrow>
                        </mfrac>
                        <mo> = </mo><mi> tan </mi><mi> &#x03B8; <!-- greek theta --> </mi>
                    </math>
                    得预测像素
                    <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                        <mi> p </mi>
                    </math>
                    的夹角
                    <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                        <mi> &#x03B8; <!-- greek theta --> </mi>
                    </math>
                    。<span class="text-gray-side mt-0">图：35种共角夹角模式。</span></p>
                </div>

                <img src="files/image21.png" alt="Directional Coding Modes" id="LR-UD-024" class="img-small img-right col-2 mb-auto" >
                <div class="align-items-center">
                    <img src="files/image22.png" alt="Directional Angle Algebra" class="img-small" >
                    <p class="text-gray-side mt-0">图：大体的精确夹角测算。见<a href="https://www.elecard.com/page/spatial_intra_prediction_in_hevc">Elecard参考书</a></p>
                </div>
            </div>

            <h4 class="same-line">量化</h4><p class="same-line">：见<a href="https://www.nazorip.site/archives/63">x264教程</a></p>
            <h2>率控制-算出量化值 Quantization Parameter</h2>
            <p>人眼对明暗变化与画面细节程度的感知呈对数㏒状，分别奠定了显示器的伽马曲线映射，以及量化值qp（x轴）到强度qScale（y轴）的强度映射。<span class="text-gray-side">图：量化值qp到qScale的映射，见<a href="https://www.desmos.com/calculator/vernjiiphf">desmos互动例</a></span>；伽马矫正的科普见<a href="https://www.nazorip.site/archives/63">x264教程</a>，<a href="https://www.artleds.com/blog/introduction-to-gamma-curves-and-gamma-correction-in-led-pixel-tapes-application">ArtLEDs科普</a>。</p>
            <img src="files/image23.png" alt="Logrithm QP to qScale" class="" >
            <p>由于当前帧此时还未编码（码率未知），故寻已编码前帧的量化失真程度（越高则后帧理应越复杂），做推演复杂度/模糊复杂度。CRF 越高则除进推演复杂度的分母越大/ABR 越低则分子越小，得到的推演复杂度越低，推演出的 qp 就越高。</p>
            
            <div class="mt-3 align-items-center">
                <table class="table-center">
                    <tr class="t-border-bottom">
                        <th class="t-light-gray">cplxSum</th>
                        <td class="text-smaller">一直于当前与上帧帧间做差并累积<br>总差异先减半一次再添加新的差异程度</td>
                        <td class="t-light-gray px-0">
                            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                                <mfrac>
                                    <mrow>
                                        <mi> c </mi><mi> p </mi><mi> l </mi><mi> x </mi><mi> S </mi><mi> u </mi><mi> m </mi>
                                        <mrow>
                                            <mo> [ </mo>
                                            <msub>
                                                <mrow>
                                                    <mi> L </mi>
                                                </mrow>
                                                <mrow>
                                                    <mo> - </mo><mn> 1 </mn>
                                                </mrow>
                                            </msub>
                                            <mo> ] </mo>
                                        </mrow>
                                    </mrow>
                                    <mrow>
                                        <mn> 2 </mn>
                                    </mrow>
                                </mfrac>
                                <mo> + </mo><mi> S </mi><mi> A </mi><mi> T </mi><mi> D </mi>
                                <mrow>
                                    <mo> [ </mo>
                                    <msub>
                                        <mrow>
                                            <mi> L </mi>
                                        </mrow>
                                        <mrow>
                                            <mo> - </mo><mn> 1 </mn>
                                        </mrow>
                                    </msub>
                                    <mo> ] </mo>
                                </mrow>
                            </math>
                        </td>
                    </tr>
                    <tr class=" t-border-bottom">
                        <th class="t-light-gray">cplxCount</th>
                        <td class="text-smaller">初始为零，用于逐帧加权 cplxBlur 的帧数计<br>÷2 与 cplxSum 同步<br>加权逻辑时越往后参考冗余理应越多的规律</td>
                        <td class="t-light-gray px-0">
                            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                                <mfrac>
                                    <mrow>
                                        <mi> c </mi><mi> p </mi><mi> l </mi><mi> x </mi><mi> C </mi><mi> o </mi><mi> u </mi><mi> n </mi><mi> t </mi>
                                        <mrow>
                                            <mo> [ </mo>
                                            <msub>
                                                <mrow>
                                                    <mi> L </mi>
                                                </mrow>
                                                <mrow>
                                                    <mo> - </mo><mn> 1 </mn>
                                                </mrow>
                                            </msub>
                                            <mo> ] </mo>
                                        </mrow>
                                    </mrow>
                                    <mrow>
                                        <mn> 2 </mn>
                                    </mrow>
                                </mfrac>
                                <mo> + </mo><mn> 1 </mn>
                            </math>
                        </td>
                    </tr>
                    <tr class="t-border-bottom">
                        <th class="t-light-gray">cplxBlur</th>
                        <td class="text-smaller">模糊复杂度。据帧所处推演加权的新 SATD<br>近似 100% 则当前帧复杂度推高（涨势复杂度）<br>可扭转 cplxCount 默认的跌势</td>
                        <td class="t-light-gray px-0">
                            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                                <mfrac>
                                    <mrow>
                                        <mi> c </mi><mi> p </mi><mi> l </mi><mi> x </mi><mi> S </mi><mi> u </mi><mi> m </mi>
                                    </mrow>
                                    <mrow><mi> c </mi><mi> p </mi><mi> l </mi><mi> x </mi><mi> C </mi><mi> o </mi><mi> u </mi><mi> n </mi><mi> t </mi>
                                    </mrow>
                                </mfrac>
                            </math>
                              
                        </td>
                    </tr>
                    <tr class="t-border-bottom">
                        <th class="t-light-gray">qScale</th>
                        <td class="text-smaller">GOP 内累计的直线化 qp，或率失真优化量化的拉格朗日值 λ<br>已编码帧的 qp 转 qScale，便于其它参数修改更新</td>
                        <td class="t-light-gray px-0">
                            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                                <mn> 0.85 </mn><mo> &#x00D7; <!-- multiplication sign --> </mo>
                                <msup>
                                    <mrow>
                                        <mn> 2 </mn>
                                    </mrow>
                                    <mrow>
                                        <mfrac>
                                            <mrow>
                                                <mi> q </mi><mi> p </mi><mo> - </mo><mn> 12 </mn>
                                            </mrow>
                                            <mrow>
                                                <mn> 6 </mn>
                                            </mrow>
                                        </mfrac>
                                    </mrow>
                                </msup>
                            </math>
                        </td>
                    </tr>
                    <tr class="t-border-bottom">
                        <th class="t-light-gray">ABR_rate_factor</th>
                        <td class="text-smaller">GOP 初始值，ABR 下的 qScale（rdoqλ）转 qp</td>
                        <td class="t-light-gray px-0">
                            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                                <mfrac>
                                    <mrow>
                                        <mi> t </mi><mi> a </mi><mi> r </mi><mi> g </mi><mi> e </mi><mi> t </mi><mo> _ </mo><mi> r </mi><mi> a </mi><mi> t </mi><mi> e </mi><mo> _ </mo><mi> w </mi><mi> i </mi><mi> n </mi><mi> d </mi><mi> o </mi><mi> w </mi>
                                    </mrow>
                                    <mrow><mi> c </mi><mi> p </mi><mi> l </mi><mi> x </mi><mi> s </mi><mi> u </mi><mi> m </mi>
                                    </mrow>
                                </mfrac>
                            </math>
                        </td>
                    </tr>
                    <tr class="t-border-bottom">
                        <th class="t-light-gray">ABR_qScaleNew</th>
                        <td class="text-smaller">据 ABR 控制更新一遍 qScale（rdoqλ）</td>
                        <td class="t-light-gray px-0">
                            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                                <mfrac>
                                    <mrow>
                                        <mrow>
                                            <mi> q </mi><mn> S </mn><mi> c </mi><mi> a </mi><mi> l </mi><mi> e </mi>
                                        </mrow>
                                        <mo> &#x00D7; <!-- multiplication sign --> </mo>
                                        <mi> o </mi><mi> v </mi><mi> e </mi><mi> r </mi><mi> f </mi><mi> l </mi><mi> o </mi><mi> w </mi>
                                    </mrow>
                                    <mrow>
                                        <mi> A </mi><mi> B </mi><mi> R </mi><mo> _ </mo><mi> r </mi><mi> a </mi><mi> t </mi><mi> e </mi><mi> f </mi><mi> a </mi><mi> c </mi><mi> t </mi><mi> o </mi><mi> r </mi>
                                    </mrow>
                                </mfrac>
                            </math>
                        </td>
                    </tr>
                    <tr class="t-border-bottom">
                        <th class="t-light-gray">cplxBase</th>
                        <td class="text-smaller">常数/恒定值。CRF 模式默认的复杂度<br>若用 B 帧编码则 CTU 或宏块数量×120, 否则×80</td>
                        <td class="t-light-gray text-smaller px-0">
                            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                                <mi> c </mi><mi> t </mi><mi> u </mi><mo> _ </mo><mi> c </mi><mi> o </mi><mi> u </mi><mi> n </mi><mi> t </mi><mo> &#x00D7; <!-- multiplication sign --> </mo>
                                <mrow>
                                    <mo> ( </mo><mi> b </mi><mi> f </mi><mi> r </mi><mi> a </mi><mi> m </mi><mi> e </mi><mo> ? </mo><mn> 120 </mn><mo> : </mo><mn> 80 </mn><mo> ) </mo>
                                </mrow>
                            </math>
                        </td>
                    </tr>
                    <tr class="t-border-bottom">
                        <th class="t-light-gray">CRF_rate_factor</th>
                        <td class="text-smaller">GOP 内累计，经 cutree，B 帧偏移乘进 qScale 后得到<br> 1-qcomp 与 CRF_qScale 对齐 （仅 cplxBase，cplxBlur运算）</td>
                        <td class="t-light-gray text-smaller px-0">
                            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                                <mfrac>
                                    <mrow>
                                        <msup>
                                            <mrow>
                                                <mrow>
                                                    <mi> c </mi><mi> p </mi><mi> l </mi><mi> x </mi><mi> B </mi><mi> a </mi><mi> s </mi><mi> e </mi>
                                                </mrow>
                                            </mrow>
                                            <mrow>
                                                <mn> 1 </mn><mo> - </mo><mi> q </mi><mi> c </mi><mi> o </mi><mi> m </mi><mi> p </mi>
                                            </mrow>
                                        </msup>
                                    </mrow>
                                    <mrow>
                                        <mi> q </mi><mi> S </mi><mi> c </mi><mi> a </mi><mi> l </mi><mi> e </mi>
                                        <mo> &#x00D7; <!-- multiplication sign --> </mo>
                                        <mo> ( </mo><mi> c </mi><mi> r </mi><mi> f </mi><mo> + </mo><mi> c </mi><mi> u </mi><mi> t </mi><mi> r </mi><mi> e </mi><mi> e </mi><mo> + </mo><mi> b </mi><mi> f </mi><mi> r </mi><mi> a </mi><mi> m </mi><mi> e </mi><mi> s </mi><mo> _ </mo><mi> o </mi><mi> f </mi><mi> f </mi><mi> s </mi><mi> e </mi><mi> t </mi><mo> ) </mo>
                                    </mrow>
                                </mfrac>
                            </math>
                        </td>
                    </tr>
                    <tr class=" t-border-bottom">
                        <th class="t-light-gray">CRF_qScaleNew</th>
                        <td class="text-smaller">据 crf_rate_factor 更新当前帧的 qScale（rdoqλ）</td>
                        <td class="t-light-gray px-0">
                            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                                <mtable columnalign='left'>
                                    <mtr>
                                        <mtd>
                                            <mfrac>
                                                <mrow>
                                                    <msup>
                                                        <mrow>
                                                            <mrow>
                                                                <mi> c </mi><mi> p </mi><mi> l </mi><mi> x </mi><mi> B </mi><mi> a </mi><mi> s </mi><mi> e </mi>
                                                            </mrow>
                                                        </mrow>
                                                        <mrow>
                                                            <mn> 1 </mn><mo> - </mo><mi> q </mi><mi> c </mi><mi> o </mi><mi> m </mi><mi> p </mi>
                                                        </mrow>
                                                    </msup>
                                                </mrow>
                                                <mrow>
                                                    <mi> C </mi><mi> R </mi><mi> F </mi><mo> _ </mo><mi> r </mi><mi> a </mi><mi> t </mi><mi> e </mi><mi> f </mi><mi> a </mi><mi> c </mi><mi> t </mi><mi> o </mi><mi> r </mi>
                                                </mrow>
                                            </mfrac>
                                        </mtd>
                                    </mtr>
                                </mtable>
                            </math>
                        </td>
                    </tr>
                    <tr class="t-border-bottom">
                        <th class="t-light-gray">qp</th>
                        <td class="text-smaller">qScale（rdoqλ）经调整后得到当前帧的量化值 qp<br>各 qp 对应一套 DCT 变换量化矩阵。qp→qStep 见<a href="https://www.nazorip.site/archives/63">x264教程</a></td>
                        <td class="t-light-gray px-0">
                            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                                <mn> 6 </mn>
                                <msub>
                                    <mrow>
                                        <mi> log </mi>
                                    </mrow>
                                    <mrow>
                                        <mn> 2 </mn>
                                    </mrow>
                                </msub>
                                <mfrac>
                                    <mrow>
                                        <mi> q </mi><mi> S </mi><mi> c </mi><mi> a </mi><mi> l </mi><mi> e </mi><mo> _ </mo><mi> n </mi><mi> e </mi><mi> w </mi>
                                    </mrow>
                                    <mrow>
                                        <mn> 0.85 </mn>
                                    </mrow>
                                </mfrac>
                                <mo> + </mo><mn> 12 </mn>
                            </math>
                              
                        </td>
                    </tr>
                </table>
                <p class="text-gray-side">表：分别以[L<sub>-1</sub>]和[L]表示上帧和当前帧</p>
            </div>

            <p>经此实现了帧内画面复杂则 qp 低，简则高；同时据用户设定的（对数）强度的动态变化。这种质量判断只有两帧而不宏观，所以引出了各种各样的优化步骤，如 mb/cutree，rdoq 等。</p>

            <h4>CRF 上层模式</h4>
            <pre><code>
<b>--crf</b>&lt;浮点范围0~51，默认23&gt;据cplxBlur，cutree，B帧偏移给每帧分配各自 qp 的固定目标质量模式，或简称质量呼应码率模式，统称crf。素材级画质设在16~18，收藏~高压画质设在19~20.5，YouTube是23。由于动画和录像的内容差距，动画比录像要给低点。理论上crf高=量化损失多→率失真优化慢；但测试出来是crf+2则4k 4:4:4 12bit会快~0.5fps
<b>--qpmin</b>&lt;整数0~51&gt;由于画质和优质参考帧呈正比，所以仅高压环境建议设最高14
<b>--qpmax</b>&lt;整数0~51&gt;在要用到颜色键，颜色替换等需要清晰物件边缘的滤镜时，可以设<span class="text-blue-emph">26</span>防止录屏时物件的边缘被压缩的太厉害，其他情况永远不如关cu/mbtree
<b>--qcomp</b>&lt;开关，tune grain时开启&gt;通过cplxBlur抑制qp判断被噪声带偏，胶片颗粒片源用
<b>--cplxblur</b>&lt;浮点0~100，默认20&gt;第-1帧不存在，无法算出第0帧的cplxBlur所以直接指定
            </code></pre>

            <h4>ABR 上层模式</h4>
            <p>编码器自行判断量化程度，尝试压缩到用户定义的平均码率average bitrate上，速度最快</p>
            <pre><code>
<b>--bitrate</b>&lt;整数kbps&gt;平均码率。若视频易压缩且码率给高，就会得到码率比设定的片子；反过来低了会不照顾画质强行提高量化，使码率达标。如果给太低则会得到码率不达标，同时画质差的片子。平均码率模式，除2pass分隔，一般推流用的"码率选项"就是这个参数，速度快但同时妥协了压缩
            </code></pre>

            <h4>SBRC 下层模式-可搭配 CRF/ABR/CRF-VBR/ABR-VBR</h4>
            <p>分段式率控制 Segment based rate control，实现DASH，M3U8串流（视频平台）用。</p>
            <pre><code>
<b>--sbrc</b>&lt;开关，<span class="text-red-emph">需min-keyint=keyint</span>，<span class="text-red-emph">no-open-gop</span>&gt;由于提高了初始CRF值的利用率，所以建议搭配--cplxblur=crf使用
            </code></pre>

            <h4>CQP 双层模式</h4>
            <pre><code>
<b>--qp</b>&lt;整数0~69，<span class="text-red-emph">禁用crf/abr+模式决策+率失真优化</span>&gt;直接设定全局量化强度。影响其后的综合画质下降或码率暴涨，所以除非yuv4:4:4情况下有既定目的，都不建议
            </code></pre>

            <h4>2pass-ABR 双层模式</h4>
            <p>先用 CRF 模式分析整个视频总结可压缩信息，后根据 ABR 模式的码率限制统一分配量化值。有 pass 2 给特别高的平均码率，输出最小损失的最小体积近无损模式，以及 pass2 给码率硬限的全局整体压缩模式</p>
            <pre><code>
<b>--pass 1</b>&lt;挡位，导出stats数据文件&gt;；<b>--pass 2</b>&lt;挡位，导入stats数据文件&gt;；<b>--stats</b>&lt;路径，默认在x264/5目录下&gt;
<b>--slow-firstpass</b>&lt;开关&gt;pass1 里不用 fast-intra no-rect no-amp early-skip ref 1 max-merge 1 me dia subme 2 rd 2，或者手动覆盖掉
            </code></pre>

            <h4>Analysis-2pass-ABR 双层模式</h4>
            <p>于普通 2pass 基础上让 pass1 的帧内帧间分析结果给到 pass2。</p>
            <pre><code>
<b>--analysis-save --analysis-load</b>&lt;路径&gt;指定导入/出analysis信息文件的路径，文件名
<b>--analysis-save-reuse-level --analysis-load-reuse-level</b>&lt;整数1~10，默认5&gt;指定analysis-save和load的信息量，配合pass1的动态搜索，帧内搜索，参考帧等参数。推荐8
    · <span class="text-blue-emph">1</span>储存lookahead信息
    · <span class="text-blue-emph">2==4</span>同时储存帧内/帧间向量格式+参考信息
    · <span class="text-blue-emph">5==6</span>加rect/amp分块信息
    · <span class="text-blue-emph">7</span>加8x8cu分块优化信息
    · <span class="text-blue-emph">8==9</span>加完整8x8cu分块信息
    · <span class="text-blue-emph">10</span>加所有cu分析信息
<b>--dynamic-refine</b>&lt;开关，默认关&gt;自动调整refine-inter，x265官方建议搭配refine-intra 4用，相比手动设定提高了压缩
<b>--refine-inter</b>&lt;整数0~3，默认0&gt;限制帧间块的向量格式，<span class="text-blue-emph">取决于pass1分析结果是否可信，如pass 1只跑了快速搜索的情况</span>
    · <span class="text-blue-emph">0</span>完全遵从pass1的分块深度和向量格式
    · <span class="text-blue-emph">1</span>分析所有pass2中与pass1相同分块的向量格式，除2pass中比1pass更大的分块
    · <span class="text-blue-emph">2</span>一旦找出最佳的动态向量格式就应用于全部的块，2Nx2N块的rect/amp分块全部遵从pass1，仅对merge和2Nx2N划分的块的动态向量信息进行分析
    · <span class="text-blue-emph">3</span>保持使用pass1的分块程度，仍然搜索向量格式
<b>--refine-intra</b>&lt;整数0~3，默认0&gt;限制帧间块的向量格式，<span class="text-blue-emph">取决于pass1分析结果是否可信，如pass 1只跑了快速搜索的情况</span>
    · <span class="text-blue-emph">0~2</span>同上
    · <span class="text-blue-emph">3</span>保持使用pass1的分块程度，但优化动态向量
    · <span class="text-blue-emph">4</span>pass1丢弃不用
<b>--refine-mv</b>&lt;整数1~3&gt;优化分辨率变化情况下pass2的最优动态向量，<span class="text-blue-emph">1</span>仅搜索动态向量周围的动态，<span class="text-blue-emph">2</span>增加搜索AMVP的顶级候选块，<span class="text-blue-emph">3</span>再搜索更多AMVP候选
<b>--scale-factor</b>&lt;整数1~3&gt;优化分辨率变化情况下pass2的最优动态向量，<span class="text-blue-emph">1</span>仅搜索动态向量周围的动态，<span class="text-blue-emph">2</span>增加搜索AMVP的顶级候选块，<span class="text-blue-emph">3</span>再搜索更多AMVP候选
<b>--refine-mv-type avc</b>读取API调用的动态信息，目前支持avc大小，使用analyse-reuse模块就用这个参数+avc
<b>--refine-ctu-distortion</b>&lt;整数0~1&gt;pass 1下用0写，pass 2下用1读取ctu失真信息
            </code></pre>

            <h4>2pass 转场优化</h4>
            <pre><code>
<b>--scenecut-aware-qp</b>&lt;整数，默认关，<span class="text-red-emph">仅pass2</span>&gt;降低转场前/后qp以增加转场画质，类似fades和weightb
    · <span class="text-blue-emph">1</span>仅转前
    · <span class="text-blue-emph">2</span>仅转后
    · <span class="text-blue-emph">3</span>前加后
<b>--analysis-reuse-file</b>&lt;路径，默认x265目录下x265_analysis.dat&gt;若使用了2pass-ABR调优，则导入multi-pass-opt-analysis/distortion信息的路径，文件名
<b>--masking-strength</b>&lt;逗号分隔整数&gt;于sct-awr-qp基础上定制qp偏移量。建议根据低~高成本动漫，真人录像三种情况定制参数值。scenecut-aware-qp的三种方向决定了masking-strength的三种方向。所谓的非参考帧就是参考参考帧的帧，包括B，b，P三种帧
    · sct-awr-qp=1时写作<span class="text-blue-emph">&lt;转前毫秒（推500）&gt;,&lt;参考±qp&gt;,&lt;非参±qp&gt;</span>
    · sct-awr-qp=2时写作<span class="text-blue-emph">&lt;转后毫秒（荐500）&gt;,&lt;参考±qp&gt;,&lt;非参±qp&gt;</span>
    · sct-awr-qp=3时写作<span class="text-blue-emph">&lt;转前毫秒&gt;,&lt;参考±qp&gt;,&lt;非参±qp&gt;,&lt;转后毫秒&gt;,&lt;参考±qp&gt;,&lt;非参±qp&gt;</span>
注：x265 v3.5移除了scenecut-window，max-qp-delta，qe-delta-ref，qp-delta-nonref
            </code></pre>

            <h4>Analysis-Npass 间调优</h4>
            <p>在Analysis-pass1~2之间加一步优化计算。实现比普通2pass更精细的码率控制，1~N也行</p>
            <pre><code>
<b>--multi-pass-opt-analysis</b>&lt;开关，默认生成x265_analysis.dat，<span class="text-red-emph">需关闭pme/pmode/analysis-save|load</span>&gt;储存/导入每个CTU的参考帧/分块/向量等信息。将信息优化，细化并省去多余计算
<b>--multi-pass-opt-distortion</b>&lt;开关，<span class="text-red-emph">需关闭pme/pmode/analysis-save|load</span>&gt;根据失真（编码前后画面差）进一步分析qp
<b>--multi-pass-opt-rps</b>&lt;开关，默认关&gt;将pass1常用的率参数集保存在序列参数集SPS里以加速
            </code></pre>

            <h4>Analysis-pass2-ABR 天梯模式</h4>
            <pre><code>
<b>--abr-ladder</b>&lt;文件名.txt，<a href="https://streaminglearningcenter.com/blogs/the-evolving-encoding-ladder-what-you-need-to-know.html">苹果TN2224</a>，<span class="text-red-emph">实验性</span>&gt;码器内部实现analysis模式2pass abr多规格压制输出。方便平台布置多分辨率版本用。可以把不变参数写进pass1+2，变化的写进txt。
格式为："[压制名:analysis-load-reuse-level:analysis-load] &lt;参数1+输出文件名1&gt;"
例：
x265.exe --abr-ladder 1440p8000_2160p11000_2160p16000.txt --fps 59.94 --input-dep例th 8 --input-csp i420 --min-keyint 60 --keyint 60 --no-open-gop --cutree
1440p8kb_2160p11kb_2160p16kb.txt {
[1440p:8:Anld存档1] --input 视频.yuv --input-res 2560x1440 --bitrate 8000 --ssim --psnr --csv 9.csv --csv-log-level 2 --output 1.hevc --scale-factor 2
[2160p1:0:nil] --input 视频.yuv --input-res 3840x2160 --bitrate 11000 --ssim --psnr --csv 10.csv --csv-log-level 2 --output 2.hevc --scale-factor 2
[2160p2:10:Anld存档3] --input视频.yuv --input-res 3840x2160 --bitrate 16000 --ssim --psnr --csv 11.csv --csv-log-level 2 --output 3.hevc --scale-factor 0 }
            </code></pre>

            <h4>近无损与真无损压缩双层模式</h4>
            <pre><code>
<b>--lossless</b>&lt;开关&gt;过分块，动/帧/参搜索，量/自适量化等影响画质的步骤，保留率失真优化以增强参考性能。输出体积特大的原画。相比锁定量化方法，这样更能满足影业与科研用，但不适合个人和一般媒体。真无损导出有很小几率因为参考质量提升而会比近无损小
<b>--tskip</b>&lt;开关，默认关，<span class="text-red-emph">需rd大于2</span>&gt;4x4 tu上跳过DCT变换，可保留深度分块/纹理密集处的放大细节
<b>--cu-lossless</b>&lt;开关，默认关&gt;将无损量化cu（qp 4）作为率失真优化的结果选项之一，只要码率管够（符合λ=R/D）就不量化。用更多码率换取原画相似度，无损源能提高参考冗余
            </code></pre>

            <h2>自适应量化</h2>
            <p>CRF/ABR设定每帧量化/qp后，方差自适应量化variance adaptive quantizer再根据复杂度判断高低频信号，来实现精确到宏块的qp分配过程。讨论时注意aq与vaq的混淆。<a href="https://www.nazorip.site/archives/63">见x264教程</a></p>
            
            <pre><code>
<b>--aq-mode</b>&lt;整数0~3&gt;据原画和crf/abr设定，以及码率不足时（crf&lt;18/低码abr）如何分配qp
    · <span class="text-blue-emph">1</span>标准自适应量化（急用，简单平面）
    · <span class="text-blue-emph">2</span>加启用aq-variance，自动调整aq-strength强度（录像-电影以及crf&lt;17推荐）
    · <span class="text-blue-emph">3</span>加码率不够用时倾向保暗场（接受更明显的涂抹失真）
    · <span class="text-blue-emph">4</span>加码率不够用时更加倾向保纹理（接受平面上的涂抹失真，<span class="text-red-emph">实验性</span>，很慢）
<b>--aq-strength</b>&lt;浮点&gt;自适应量化强度。搭配aq-mode，如动漫1:0.8，2:0.9，3:0.7用。录像上可加0.1~0.2，画面混乱/观众难以注意平面时可再增加。注意低成本动漫的平面居多，因此码率不足时反而要妥协纹理
<b>--hevc-aq</b>&lt;开关&gt;以¼tile而非aq的边缘高频信息实现自适应。据doom9结论<a href="https://forum.doom9.org/showthread.php?p=1925373#post1925373">1</a>，<a href="https://forum.doom9.org/showthread.php?p=1925464">2</a>: hevc-aq比aq 4快且适合动漫，而aq 4更适合录播。目前学术方-官方-第三方间信息较割裂，暂无适解
<b>--aq-motion</b>&lt;开关，<span class="text-red-emph">实验性</a>&gt;据动态信息微调自适应量化的效果mode和强度strength
<b>--qg-size</b>&lt;64/32/16/8，默认64，<span class="text-red-emph">≥min-cu-size</span>&gt;偏移蓝，红色色度面相比亮度平面的qp值差异，负值降低量化。如当色度平面的量化太高则可以用这两个参数补偿回来，但x264-5会根据色度平面采样格式（4:2:2，4:4:4）自动设定这些参数。由于编码器一直不擅长深红色，而人眼又对红光敏感，所以可以给红色面设<span class="text-blue-emph">-3</span>左右
<b>--cbqpoffs --crqpoffs</b>&lt;整数&gt;据动态信息微调自适应量化的效果mode和强度strength
            </code></pre>

            <h4>x265 jpsdr-mod 参数</h4>
            <pre class="mb-0"><code>
<b>--aq-auto</b>&lt;8bit四开关十进制，默认0关&gt;对应下表：
            </code></pre>
            <div class="align-items-center">
                <table class="table-center">
                    <thead>
                        <tr class="t-border-bottom">
                            <th>值</th>
                            <th>逐帧aq</th>
                            <th>延迟逐帧aq(hysteresis)</th>
                            <th>HDR兼容</th>
                            <th>aq-mode 5</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="t-border-bottom t-light-gray">
                            <td>1</td>
                            <td>√</td>
                            <td> </td>
                            <td> </td>
                            <td> </td>
                        </tr>
                        <tr class="t-border-bottom">
                            <td>2,3</td>
                            <td>√</td>
                            <td>√</td>
                            <td> </td>
                            <td> </td>
                        </tr>
                        <tr class="t-border-bottom t-light-gray">
                            <td>4</td>
                            <td>√</td>
                            <td> </td>
                            <td>√</td>
                            <td> </td>
                        </tr>
                        <tr class="t-border-bottom">
                            <td>8</td>
                            <td>√</td>
                            <td> </td>
                            <td> </td>
                            <td>√</td>
                        </tr>
                        <tr class="t-border-bottom t-light-gray">
                            <td>6</td>
                            <td>√</td>
                            <td>√</td>
                            <td>√</td>
                            <td> </td>
                        </tr>
                        <tr class="t-border-bottom">
                            <td>10</td>
                            <td>√</td>
                            <td>√</td>
                            <td> </td>
                            <td>√</td>
                        </tr>
                        <tr class="t-border-bottom t-light-gray">
                            <td>12</td>
                            <td>√</td>
                            <td> </td>
                            <td>√</td>
                            <td>√</td>
                        </tr>
                        <tr class="t-border-bottom">
                            <td>14</td>
                            <td>√</td>
                            <td>√</td>
                            <td>√</td>
                            <td>√</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <pre><code>
<b>-aq-fast-edge</b>&lt;开关，<span class="text-red-emph">需aq-mode4,5</span>&gt;边缘检测跳过高斯模糊过滤，不适合脏片源
<b>--aq-bias-strength</b>&lt;浮点，默认1，<span class="text-red-emph">需aq-mode3,5</span>&gt;aq-strength偏给暗场的程度
<b>--aq-strength-edge</b>&lt;浮点0~3，默认=aq-strength，<span class="text-red-emph">需aq-mode4,5</span>&gt;偏给纹理的aq-strength
<b>--aq-bias-strength-edge</b>&lt;浮点，默认=aq-bias-str，<span class="text-red-emph">需aq-mode5</span>&gt;aq-strength-edge偏给暗场的程度
            </code></pre>

            <h2>模式决策</h2>
            <p>Mode decision 整合搜来的信息，宏观地定制分块参考量化等细分方案。因为码率最小的压缩方案画质也差。注意片源含明显边缘失真时反而要减少决策优化</p>
            <div class="align-items-center">
                <img src="files/image24.png" alt="Mode Decision General" class="" >
            </div>

            <pre><code>
<b>--rd</b>&lt;1/2/3/5，默认3，大则慢&gt;据优化模式决策的程度。 建议快速用<span class="text-blue-emph">1</span>，<span class="text-blue-emph">2</span>；高压用<span class="text-blue-emph">3</span>；片源数据无损(非视觉无损)时用<span class="text-blue-emph">5</span>
    · <span class="text-blue-emph">1</span>优化帧内参考，并块/跳过决策，含明显边缘失真时用
    · <span class="text-blue-emph">2</span>加分块决策，含明显边缘失真时用
    · <span class="text-blue-emph">3</span>加帧间决策，高压高量化时可平衡
    · <span class="text-blue-emph">5==6</span>加向量/帧间方向预测决策，比3慢一倍，片源含边缘失真时会强化失真
<b>--limit-modes</b>&lt;开关&gt;用附近的4个子CU以判断用merge还是AMVP，会大幅减少rect/amp的效果，提速明显。会增大或减少体积，微降画质但难以察觉
<b>--limit-refs</b>&lt;整数0~3，默认3&gt;限制分块用信息可参考性。<span class="text-blue-emph">0不限</span>压缩高且慢；<span class="text-blue-emph">1</span>用cu分裂后的信息+差异信息描述自身(推荐)；<span class="text-blue-emph">2</span>据单个cb的差异信息建立pu；<span class="text-blue-emph">3=1+2</span>
<b>--rskip</b>&lt;整数0~2&gt;前cu分块被跳过时，判断后cu接着搜索分块还是提前退出的参数。画面越接近录屏/低成本动漫就用得越多
    · <span class="text-blue-emph">0</span>继续分析。适合信噪比差/高噪源。原画很干净则不如<span class="text-blue-emph">1</span>
    · <span class="text-blue-emph">1</span>rd0~4下据临cu是否细分而定；rd5~6下看附近2Nx2N cu分块难度而定，高压和一般情况推荐
    · <span class="text-blue-emph">2</span>直接对比cu纹理密度edge density，快且不比前者差，但存在对源的画质要求及客观判断“画质”的能力
<b>--tskip-fast</b>&lt;开关，默认关&gt;跳过4x4 tu的变换，忽略部分DCT系子coefficients来加速，CbCr-tu也取决于Y块是否被跳过。在全屏小细节的视频中有显著加速效果。建议除高压以外的情况使用
<b>--rskip-edge-threshold</b>&lt;0~100，默认5: 趋向于分块，<span class="text-red-emph">需rskip大于1</span>&gt;用Sobel算法获取cu纹理密度再除以块所占面积的百分比。纹理密度&gt;阈值=分块，量化强度越高越关键。8×8或16×16块下默认5%（即含3或12个系子）就分
注：类似x264 deadzone参数
    · 像素风：<span class="text-blue-emph">据像素变大的程度决定</span>。如分辨率宽÷2，分辨率高÷2会回到1x1像素大小，则使默认值乘以2以提速
    · 抗涂抹：<span class="text-blue-emph">rskip 2 rskip-edge-threshold 3</span>。即“有一点不平就应分块”。比rskip 0快，用于已知要保留雪景等全屏大量动态信息的源的情况下，节省传统分块计算时间。可=在不添噪点的情况下达成抗涂抹的目的
            </code></pre>
            <div class="align-items-center">
                <img src="files/image25.png" alt="rSkip Edge Threshold" class="img-small" >
                <p class="text-gray-side">图：影响DCT系子分布的块中像素，而DCT系子的密度影响rskip-edge-threshold的设置</p>
            </div>

            <h2>率失真优化控制</h2>
            <h4>率失真优化 Rate distortion optimization</h4>
            <p>多个码率下测得的 cu 失真，挑出 R-D 曲线下的平衡区间。由代价函数开销=失真+λ·码率：
            <math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math">
                <mi> J </mi><mo> = </mo><mi> D </mi><mo> + </mo><mi> &#x03BB; <!-- greek lambda --> </mi><mo> &#x00B7; <!-- middle dot --> </mo><mi> R </mi>
            </math>
            实现模式决策。</p>
            <p>失真 D 用差异平方和 SSE 或总差异 SAD 判断（SSE多取一步平方，使较大的差异呈指数增长）进而分到更多补偿的码率。拉格朗日值λ源于 qp，即 crf，abr 指定的率失真斜率 slope 区间。qp 越大斜度越小：</p>
            <ul>
                <li><math xmlns='http://www.w3.org/1998/Math/MathML' class="text-blue-math"><mi> &#x03BB; <!-- greek lambda --> </mi><mo> = </mo><mi> 0 </mi></math>则无斜度，则代价等于失真——码率变而画质不变，宜压缩。</li>
                <li>λ趋0则开销趋失真——适当压缩就不会影响画质</li>
                <li>λ>0则开销>失真——保画质收益大于压缩收益，应该保画质</li>
            </ul>
            <div class="align-items-center">
                <img src="files/image26.png" alt="x264 JM RDO Lambda" class="" >
                <img src="files/image27.png" alt="RDO Lambda Slopes" class="img-medium" >
                <p class="text-gray-side">图：率失真优化中λ的斜度变化与效果</p>
                <img src="files/image28.png" alt="RDO qStep Chart" class="img-medium" >
                <p class="text-gray-side">图：率-失真表格中不断调整并得到“×”的实际效果</p>
            </div>
        </div>

        <!-- Footer -->
        <footer class="py-3 my-4 align-items-center border-top">
            <p>
                联系方式：
                <a href='https://github.com/iAvoe/'>Github</a>，
                <a href='https://jq.qq.com/?_wv=1027&k=5YJFXyf'>QQ群：691892901</a>
            </p>
            &#x24B8; iAvoe，2024
        </footer>
        
	</body>
</html>